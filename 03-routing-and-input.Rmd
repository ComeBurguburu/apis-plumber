
# Routing & Input {#routing-and-input}

Plumber's first job is to execute R code in response to incoming HTTP requests, so it's important to understand how incoming HTTP requests get translated into the execution of R functions.

## Routing {#routing}

An incoming HTTP request must be "routed" to one or more R functions. Plumber has two distinct families of functions that it handles: endpoints and filters. A typically HTTP request may be routed through some number of filters before ultimately being serviced by a single endpoint.

### Endpoints {#endpoints}

Endpoints are the terminal step in the process of serving a request. An endpoint can simply be viewed as the logic that is ultimately responsible for generating a response to a particular request. A request will be checked against each available endpoint until it finds an endpoint willing to serve it at which point it stops looking; i.e. a request will not ever be processed by more than one endpoint. You create an endpoint by annotating a function like so:

```{r, echo=FALSE, results='asis'}
include_r("files/apis/03-01-endpoint.R")
```

This annotation specifies that this function is responsible for generating the response to any `GET` request to `/hello`. The value returned from the function will be used as the response to the request (after being run through a serializer to e.g. convert the response into JSON). In this case, a `GET` response to `/hello` would return the content `["hello world"]` with a `JSON` `Content-Type`.

The annotations that generate an endpoint include:

 - `@get`
 - `@post`
 - `@put`
 - `@delete`
 - `@head`

These map to the HTTP methods that an API client might send along with a request. By default when you open a page in a web browser, that sends a `GET` request to the API. But you can use other API clients (or even JavaScript inside of a web browser) to form HTTP requests using the other methods listed here. There are conventions around when each of these methods should be used which you can read more about [here](http://www.restapitutorial.com/lessons/httpmethods.html). Note that some of these conventions carry with them security implications, so it's a good idea to follow the recommended uses for each method until you fully understand why you might deviate from them.

Note that a single endpoint can support multiple verbs. The following function would be used to service any incoming `GET`, `POST`, or `PUT` request to `/cars`.

```r
#' @get /cars
#' @post /cars
#' @put /cars
function(){
  ...
}
```

### Dynamic Routes {#dynamic-routes}

In addition to having hardcoded routes like `/hello`, Plumber endpoints can have dynamic routes. Dynamic routes allow endpoints to define a more flexible set of paths against which they should match.

A common REST convention is to include the identifier of an object in the API paths associated with it. So to lookup information about user #13, you might make a `GET` request to the path `/users/13`. Rather than having to register routes for every user your API might possible encounter, you can use a dynamic route to associate an endpoint with a variety of paths.

```{r, echo=FALSE, results='asis'}
include_r("files/apis/03-01-dynamic.R")
```

This API uses the dynamic path `/users/<id>` to match any request that is of the form `/users/` followed by some path element like a number or letters. In this case, it will return information about the user if a user with the associated ID was found, or an empty object if not.

You can name these dynamic path elements however you'd like, but note that the name used in the dynamic path must match the name of the parameter for the functon (in this case, both `id`).

You can even do more complex dynamic routes like:

```r
#' @get /user/<from>/connect/<to>
function(from, to){
  # Do something with the `from` and `to` variables...
}
```

In both the hardcoded and dynamic examples given above, the parameters will be provided to the function as a character string.

### Typed Dynamic Routes {#typed-dynamic-routes}

Unless otherwise instructed, all parameters passed into plumber endpoints from query strings or dynamic paths will be character strings. For example, consider the following API.

```{r, echo=FALSE, results='asis'}
include_r("files/apis/03-02-types.R")
```

Visiting http://localhost:8000/types/14 will return:

```{r, echo=FALSE, results='asis'}
pr <- plumber::plumb("files/apis/03-02-types.R")
e <- pr$endpoints[[1]][[1]]
code_chunk(json_serialize(e$exec(id="14")), "json")
```

If you only intend to support a particular data type for a particular parameter in your dynamic route, you can specify the desired type in the route itself.

```r
#* @get /user/<id:int>
function(id){
  next <- id + 1
  # ...
}

#* @post /user/activated/<active:bool>
function(active){
  if (!active){
    # ...
  }
}
```

Specifying the type of a dynamic path element will also narrow the paths that will match the endpoint. For instance, the path `/users/123` will match the first endpoint, but `/users/8e3k` will not, since `8e3k` is not an integer.

The following details the mapping of the type names that you can use in your dynamic types and how they map to R data types.

R Type  | Plumber Name
------- | ---------
logical |	`bool`, `logical`
numeric	| `double`, `numeric`
integer	| `int`

### Filters {#filters}

## Input Handling {#input-handling}

Howwhat things get from request to parameters

Conflicts between path, query string, body?
